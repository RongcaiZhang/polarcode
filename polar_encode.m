tic;                                 %计时
clear;                             %清除变量
%获取码长
N=input('请输入码长（64 or 1024）：');
if  N ~= 64 && N ~= 1024
     error('Error:Input must be 256 or 1024.')
end
%获取信噪比
SNR=input('请输入信噪比：');
var=N/(10^(SNR/10)*2*(N/2-24));  %计算方差

%获取编码数量
Num=input('请输入编码数量：');

%位置信息
A_256 = [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
             0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
             0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
             0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1 ...
             0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 ...
             0 0 0 0 0 0 0 1 0 0 0 1 0 1 1 1 ...
             0 0 0 0 0 0 0 1 0 1 1 1 1 1 1 1 ...
             0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
             0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 ...
             0 0 0 0 0 0 1 1 0 1 1 1 1 1 1 1 ...
             0 0 0 1 0 1 1 1 0 1 1 1 1 1 1 1 ...
             0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
             0 0 0 1 0 1 1 1 0 1 1 1 1 1 1 1 ...
             1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
             1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
             1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1];
A_1024 = [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
             0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
             0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
             0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 ...
             0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
             0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 ...
             0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 ...
             0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1 0 0 0 1 0 1 1 1 0 1 1 1 1 1 1 1 ...
             0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
             0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 ...
             0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 1 1 ...
             0 0 0 0 0 0 0 1 0 0 0 1 0 1 1 1 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
             0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 1 1 1 1 ...
             0 0 0 0 0 0 1 1 0 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
             0 0 0 1 0 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
             0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
             0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
             0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 1 1 1 ...
             0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 1 1 1 1 1 1 ...
             0 0 0 0 0 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
             0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 1 0 1 1 1 0 1 1 1 1 1 1 1 ...
             0 0 0 1 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
             0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
             1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
             0 0 0 0 0 0 0 1 0 0 0 1 0 1 1 1 0 0 0 1 0 1 1 1 1 1 1 1 1 1 1 1 ...
             0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
             0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
             1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
             0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
             1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
             1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ...
             1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1];

 %位置信息
A_64 = [0,0,0,0,0,0,0,0, ...
     0,0,0,0,0,0,0,1, ... 
     0,0,0,0,0,0,0,1, ...
     0,0,1,1,1,1,1,1, ...
     0,0,0,0,0,0,1,1, ...
     0,1,1,1,1,1,1,1, ...
     0,1,1,1,1,1,1,1, ...
     1,1,1,1,1,1,1,1];
 %}
 
if N == 64
    A = A_64;
elseif N == 1024
    A = A_1024;
end

%g = [1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,1,1,0,1,1];    %根据生成多项式G(x)得到的生成多项式序列g
g = [];
%矩阵F的n次Kronecker积
F = [1,0;1,1];
FTemp = F;
for i = 1:log2(N)-1
    F = kron(FTemp,F);
end
%反序重排预处理
Xnum = [0:N-1];
NumTemp=bitrevorder(Xnum);

for k=1:Num
    uf = round(rand(1,N/2));   %随机产生信息比特
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%模块名称：生成混合序列
%输入：信息比特uf,生成多项式序列g
%输出：混合序列u1
%模块功能描述：根据uf和g产成crc校验位，合成信息序列uA，根据位置信息得到u1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    glen = length(g);
    uff= [uf,zeros(1,glen-1)];         %信息比特序列左移，uff为左移后的序列

    ulen = length(uff);
    crc = uff(1:glen-1);                %crc为生成的校验位
    %{
    for i = glen:ulen
        crc(glen) = uff(i);
        if crc(1)
            crc = xor(crc(2:glen), g(2:glen));  %异或运算，相当于除法
        else
            crc = crc(2:glen);
        end
    end
    %}
    uA = [uf,crc];      %信息比特序列=[自由比特序列,校验位]

    %%根据信息比特序列和位置序列A得到混合序列u1
    B=zeros(1,N);
    j=1;
    for i=1:N    
        if A(i)
            B(i) = uA(j);
            j = j + 1;
        end
    end
  %  u1(1024) = 0;
    u1 = B;
    
    if N == 64
        if k==1
            fid = fopen('256/send.bin','wb');       %写入 256/ 目录
        else
            fid = fopen('256/send.bin','ab');
        end
    elseif N == 1024
        if k==1
            fid = fopen('1024/send.bin','wb');      %写入 1024/ 目录
        else
            fid = fopen('1024/send.bin','ab');
        end
    end

    num1 = fwrite(fid,u1,'uint32');
    fclose('all');
    

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%模块名称：混合序列处理
%输入：混合序列u1
%输出：反序重排序列X
%功能描述；混合序列u1乘以n次Kronecker积得到V，V反序重排得到X
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%方案一，计算速度快，建议软件编码时使用   
 V = u1 * F;
%方案二，与硬件思路相对应
%    gm = zeros(N,1);
%    gm(1) = 1 ;
%    for i = 1:N
%        V(N-i+1) = u1(N-i+1:N) * gm(1:i);
%        if (i<N)
%           for j =2 :i+1
%              gm2(j) = xor( gm(j),gm(j-1));
%           end
%           for j =2 :i+1
%              gm(j) =  gm2(j);
%           end     
%        end
%    end
    
 %对2取余 
    for i=1:length(V)
        if mod(V(i),2) == 0;
            V(i) = 0;
        else
            V(i) = 1;
        end
    end
%反序重排，X为重排后的序列

    for i=1:N
        X(NumTemp(i)+1) = V(i);
    end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%模块名称：BPSK+AWGN
%输入：反序重排序列X
%输出：Y
%功能描述：进行BPSK，添加AWGN噪声
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    noises = sqrt(var) * randn(1, N);       %随机噪声
    
    for i = 1:N
        if X(i) == 0
            Y(i) = 1 + noises(i);
        else
            Y(i) = -1 + noises(i);
        end
    end
  
    Y = (2*Y)/var; 
    
%为简化解码，软件仿真时直接发送 LLR
%


    %}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%模块名称：生成二进制文件
%输入：
%输出：
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        if N == 64
            if k==1
                fid = fopen('256/input.bin','wb');       %写入 256/ 目录
            else
                fid = fopen('256/input.bin','ab');
            end
        elseif N == 1024
            if k==1
                fid = fopen('1024/input.bin','wb');      %写入 1024/ 目录
            else
                fid = fopen('1024/input.bin','ab');
            end
        end
    num2 = fwrite(fid,Y,'float');
    fclose('all');
    
end
toc;
