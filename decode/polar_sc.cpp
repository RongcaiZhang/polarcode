/*********************************************************************************
*团队：5G-037
*作者：xsfan
*说明：SC 算法主要程序
*********************************************************************************/

/************************************头文件**************************************/
#include "polar_sc.h"
#include "polar_scl.h"
#include "includes.h"
#include "gen_tx.h"

/***********************************变量定义*************************************/
float llr[LENGTH];				//输入序列 L(y)
bool location[LENGTH];			//位置信息
int invInfo[LENGTH];			//反序表
bool send[LENGTH];				//原发送序列，即对比序列
bool decode[LENGTH];			//译码输出序列

/*********************************************************************************
*功能：计算不同路径的度量值
*参数：i:层数
*返回值：第i层度量值
*********************************************************************************/
void PM_sc(int i)
{	
	float logResult;

	logResult = LLR(codeLength,i,decode,invInfo[i-1],0);  //当前比特对数似然值

	/*查询位置信息，若为固定比特，为0*/
	if(location[i-1] == 0)
	{	
		decode[i-1] = 0;
	}
	/*若为信息比特，根据 logResult 符号选择译码结果*/
	else 
	{
		decode[i-1] = logResult>=0? 0:1;
	}
}

/*********************************************************************************
*功能：SC 译码
*参数：无
*返回值：1024位译码序列
*********************************************************************************/
void Polar_sc()
{
	int i;

	searchList = 1;
	if (codeLength == 1024)
	{
		PMPrepare(128);			//码长为1024时，计算第128位
		i = 128;
	}
	else
	{
		PMPrepare(6);			//码长为256时，计算第60位
		i = 6;
	}

	for(;i<codeLength;i++)		//计算第其它位
	{
		PM_sc(i+1);
	}
}